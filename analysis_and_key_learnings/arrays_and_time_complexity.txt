- O(1) - refers to something done a constant number of times
- We always consider the largest exponent of the varible hence
  O(n/2) = O(n)

  for(i=1; i<n; i=i*2){
    ...                     1 i=1
							2 i=2
							3 i=(2^1) * 2
	}						  i=(2^2) * 2
							  i=(2^k) * 2 

							   2^k = n

							   k = log(n)

   k depicts how many times the statement is executed

- merge sort, quick sort, counting sort, heap sort
  (most of the times we will use merge sort)
- use binary search when
  1. Array is sorted
  2. Array is increading then decreasing
  3. Sorted array is rotated, and find one particular number in the array
  4. Array given in zigzag format(increasing then decreasing)

Key Learnings: binary search
- In binary serach ALWAYS ASK whether we want to return the index or the value
- while loop + recursion = INFINITE LOOP!!!!
- In recursive calls, the inner method calls return value to the parent method, not to the main method
- in recursion, first add the condiion to exit the loop
  
  def binarySearch(array, left, right, key):
	    if left > right:
	        return -1
- we can either use
  key = (low+high) // 2
  or
  key = low + ((high-low)/2) #to avoid overflow

-keep selecting left half and right half until we are only left with that single element
-discard all elements in the left and right search space
    # including the mid element


Key Learnings: merge sort
- Divide and conquer: keep dividing array into 2 sub-arrays until we are left with
  a single element in each sub-array 
  - Keep an auxillary array, which has copy of original array initially
    do some processing(swapping etc)
    get the result back to the original array from the auxillary array

Key Learnings: recursion
- The remaining elements of the function AFTER the recursive call do not get executed and 
  are stored in the stack
- The preceding function calls are stored in the stack
  Types of Recursion
  1. Recursion within a for loop
  2. two recursions within a function(binary tree)
  3. multiple recursion calls within a method(knight walk problem backtracking

- loop invariant: condition which is true before and after a loop is completed

Key Learnings: Maximum element in array using binary search
 - identify and solve the corner cases(edge cases) first
   - if 2 elements
   - if just a single element

Key Learnings: sort arrays comprising of 0,1 and 2
   - avoid index != end (since this leads to index=end not being executed)
     instead use index <= end
   - rename index as pivot

Key Learnings: minimum number of jumps 
   - avoid too many if statements
   - unable to think and code 
   - max(i+a[i]) instead of max(a[i])

Key Learnings: next largest number
   - do not waste too much time solving the problem, we have to do 10000 more :-)
   - create the algorithm first and write it down as comments 
     before jumping towards writing the code

Key Learnings: rectangle overlap problem
   - x-y coordinates of both rectangles was confusing enought to be grasped

Key Learnings: minimum number of platforms
   Greedy approach
   - The AHA moment is the "total platforms needed at any point"
   - We sort both arrivals and departure
     Then increment platforms for a new arrival
     Decrement platforms for new departure

   - Think if we should use arr[i] <= dep[j] or arr[i] < dep[j]
     Do not miss the == condition
   - Should we initialize i with 0 or 1 and why, i started with 0

Key Learnings: frequency of array elements
  - Make use of array index values(as numbers range from 1 to n)
  - add or subract values(length of array) to array indexes and use them as psuedo hash maps

Key Learnings: rotate a matrix by 90 degrees
  - Option1: Rotate groups of 4 cells
  - Option2: Transpose and reverse
  - Focus on INDIVIDUAL ELEMENTS present on all 4 CORNERS
  - The place of A[0][0] will be filled by A[3][0] (clockwise)
    SO LOOK THE OTHER DIRECTION/WAY!!!
  - int n = A.length;
    for(int i = 0 ; i < n/2; i++){
        // i constant
        // j varying
        for(int j = i; j < n - 1 - i; j++){
            int temp = A[i][j]; // top row constant
            A[i][j] = A[n-1-j][i];   // left column constant
            A[n-1-j][i] = A[n-i-1][n-1-j]; // bottom row constant 
            A[n-i-1][n-1-j] = A[j][n-1-i]; //right column constant
            A[j][n-1-i] = temp;
        }
        
    }
  -180 degree rotate
  int temp1 = A[i][j]; 
  A[i][j] = A[n-i-1][n-1-j];
  A[n-i-1][n-1-j] = temp1;
  
  int temp2 = A[j][n-1-i];
  A[j][n-1-i] = A[n-1-j][i];
  A[n-1-j][i] = temp2;

  -


Key Learnings: celebrity problem 
  - Start from top left
    Increment row or decrement column, based on whether they know each other or not

Key learnings: closest get_palindrome  
  - Don't get stuck on hard problems.
    LOOK THE SOLUTION AND MOVE ON!!

Key learnings: quickselect get kth smallest element
  - select pivot and move it to last element before using algorithm
  - compare our code with actual elements 
    appreciate the similarities, critique the differences
    change the differences after looking the code and run it again and move on
  - Be VERY careful about j+1 vs j or whenever using N-j-1
  - In recursion we can use global array, or we need to
    modify the array and the variables accordingly
  - Learn how to save the results of inner nested method in recursion
    YOU ALWAYS RETURN A RECURSIVE FUCNTION CALL
  - Re-read your code, re-read your solution and identify the difference
    STOP RUNNING THE SOLUTION AGAIN AND AGAIN before dry running
  -    k -(index - low) - 1
    => k - index + low - 1

    Eg 0 1 2 3   4  5
             val    k
    will become  0 1
                   k

        k - (index-low) - 1
        5 - (3) - 1 = 1
     
  - THE START AND END INDICES CHANGE WITH EVERY RECURSIVE CALL
    they do not stay the same as the global start and end index

Key Learnings: count distinct element in each window
   - when hash_map value becomes zero, decrement the count
   - when hash_map value becomes exactly one, increment the count
   - when hash_map value is more than one, don't do anything


Key Learning: find single element using xor
   - AT LEAST DRY RUN THE CODE ONCE, REMOVE SYNTAX AND SEMANTIC ERRORS

Key Learnings: find 2 unique numbers
   - 7 ^ 9 = 
     0110
   ^ 1001
     1110

     1 signifies one of the bit has zero and other bit has one

     find all numbers having that bit postion has one
          and numbers having that bit position as zero

     and xor them separately

     # check if particular bit is set(bit index starting from zero)
     init_xor & (1<<bit) == 1
   - you always use AND(&) operator with a MASK

Key Learnings: Row with maximum ones
     mid = (low+high) // 2 #do not forget the bracket
     Also

     mid = low + (high - low) // 2 #to avoid overflow
     # this ensures the number is always positive

     5 // 2 #2
     5 >> 1 #2
     both are same

Key Learnings: Rain water trapping problem
   2-pointer approach
   -i is the left pointer
   -j is the right pointer
   -if A[i] < A[j]
       A[i] will depend on left_max(INCORRECT)
       water filled in A[i] will depend on the left_max(CORRECT)
    else:
       water filled in A{j} will depend on the right_max

   -start with A[i] < A[j] and inititialize left_max = right_max = 0
    instead of left_max < right_max
   -Never initialize left_max and right_max values as first/last element
    initialize them as 0/float("inf")/-float("inf") - why??
   -Do update the leftmax(or rightmax) before computing the final trapped water result
   -leftmax, rightmax only used for computing the final result,
    for comparing left and right heights we use A[i] <= A[j] 

Key Learnings: Max Distance
    Given an array A of integers of size N. Find the maximum of value of j - i such that A[i] <= A[j].

    -Sometimes we should consider sorting the elements
    Create a PAIR of value and index, then SORT this array. 
Start traversing from the last element, since all elements to the right of this will be greater than the current element

Key Learnings: Minimum swaps
   -You got to MAINTAIN a WINDOW, then track the numbers greater than B in that window, 
   and return the minimum such window
   -Move to solution if coding is wrong(before that at least do a dry run first)
   -Please avoid l+=1 followed by l-1, when l is all that is required

Key Learnings: Powers of 3
   - while num * 3 < A:
        num *= 3 
   - IN PLACE Of
     while num < A:
        num *= 3 
     num /= 3
   - Could have used modulus as well

Key Learnings - nth magic number
   - Decide what should be the INITIAL VALUE of the variables
   - 2**(n-1) should have given me an intuition about binary numbers

Key Learnings - sub matrix sum queries
   - A[c,d] WRONG
   - A[c][d] CORRECT

   - Not all matrices can be square matrix
     matricx can also be of size nxm
     n = len(A)
     m = len(A[0])

   - Read the question TWICE
   - Dry run the changes to code at least once

   - if some answers require mod by 10**9 + 7
     and we are subtracting the numbers, then do add the following condition
   if (res[i] < 0){
      res[i] = res[i] + (int)mod;
   }


Compute gcd 

def ggcd(self, a,b):
    if b == 0:
        return a

    return self.ggcd(b,a%b)

Key Learnings: Delete one
   Be very careful with the tilde(~) symbol

Key Learnings: GCD pair 
   If you don't understand the problem or you test wrong more than 3 times. 
   Then it's time to look at the video explanation

Key Learnings: Largest Coprime Divisor
    We are trying to make A and B co-prime 
    by diving the the common factors of A and B (i.e. gcd(A,B)) from A

Key Learning: Odd fibonacci
    To get a value k 
    1. You can either focus on getting k
    2. Or focus on getting n - (n-k)
        since getting n-k is easier

Key Learnings: Sorted Permutation Rank
    -use the LOOP CONTROL VARIABLE inside a LOOP!!!!!!!

    for i in range(val_index):
				if visited[i] == 0: #CORRECT
					num_elements_above += 1

    for i in range(val_index):
				if visited[val_index] == 0: #INCORRECT
					num_elements_above += 1

    - if answer required modulus by 10**9+7 or some large number
      it gives an indication that we should use the mod while
      perfomring internal computations


Key Learnings: Multiplicative inverse
    - When multiplying SET res AS 1
    - When multiplying use integer divide b//=2

Key Learnings: Histogram problem, max rectangular area 
    - You append the index ONLY WHILE PUSHING not during popping
    - Start adding comments for every variable
    - It's not stack[-1], it's a[stack[-1]]
    - DO NOT ADD ANOTHER INNER WHILE LOOP
      THE OUTER LOOP WILL TAKE CARE OF THE BOTH PUSHING AND POPPING
    - height = index - stack[-1] - 1