Recognize if a problem requires DP or not
1. optimization, mimimum, maximum
2. requires a number and not a word?
3. requires 2 or more recursion
4. note the recurrence to store the final problem?
5. There is some form of choice(eg: knapsack)


1. KNAPSACK PROBLEM
   - Use W in recursive approach, since the param value changes in subsequent
     recursive calls

   - Replace W with loop variable j in iterative approach
     Since ....
    - i : n (i is analogous to n)
      j : w (j is analogous to W)

      for any subproblem 
        consider it as an actual problem
        where number of items is i
        and the maximum possible knapsack weight is j

2. Recursive leap of faith

   - 1. What is the simplest possible input?
   - 2. Play around with examples and visualize(write a lot of examples)
        to find key insights to solution
     3. Notice any interesting relation amongst the partitions
     4. Relate hard case to simpler(smaller) cases
     5. Generalize the pattern
     6. Write code by combining recursive pattern with the base case


3. WE TELL COMPUTER WHAT TO SOLVE BUT NOT HOW TO SOLVE IT
   We teach the computer how to solve base case
   and give the formula of the general case

4. DP approaches
   1. visualize the problems
   2. FIND RELATIONSHIPS AMONG SUBPROBLEMS
   3. GENERALIZE THE RELATIONSHIPS
   4. \


5. Longest common subsequence
   Case 1: characters match
           a[i][j] = a[i-1][j-1] + 1
   Case 2: characters do not match
           a[i][j] = max(a[i][j-1], a[i-1][j])

6. Minimum edit distance
   Initializing an array
   if i== 0
      dp[i][j] = j (Correct)

      dp[i][j] = dp[i][j-1] + 1(Incorrect or stupid)

   Valid approach: 
         1. Initialize 2d matrix
         2. understand how to fill first row and first column
         3, fill other cells using the first row and first column
   
   Another approach
      1. Determine smallest input
      2. understand what happens if one input has a lenght of more than one
         whereas other only has one, and vice versa

         Eg s1 = "abcdefgh"
            s2 = "a" (or None)


7. Knapsack - similar to - subset sum
   knapsack: weight
   subset sum: final sum

8. knapsack
   
   wt [] #always considered, equivalent to coins[] etc.
   val []

   W #equivalent to sum(in coin change problem) etc.

9. Unbounded knapsack: 
   Determine NUMBER OF ways
   Place a + symbol

10. (INVESTIGATE THIS FURTHER)
    Unbounded
    t[i][j-arr[i-1]]

    vs

    Others
    t[i-1][j-arr[i-1]]


11. Counting bits: leetcode
    -PLEASE CONSIDER USING THE LOOP VARIABLES(i) instead of FUNCTION PARAM(n)
     for an iterative approach

     Incorrect
     def func(n):
         for i in n:
            if n%2 == 0
               return n + 1

     Correct
     def func(n):
         for i in n:
            if i%2 == 0
               return i + 1

    - one liner
      for i in range(1, n+1):
          dp[i] = dp[i//2] + i%2


12. Maximum subarray(Kadane's algortihm)
    -2 separate max_variables required
    -one for updating local max
     i.e. discarding previous elements
          if current element greater than previously computed sum
    -one for updating global max value, used in result
    -max_current will increment when we see a value whose sum
     is greater than the current maximum

    -short cut to compute prefix_sum
     prefix_sum = [r for r in itertools.accumulate(a)]

    -another solution
      min_sum = max_sum = 0
      for r in accumulate(a):
         min_sum = min(min_sum, r)

         # dp[i] = max(dp[i], r-min_sum)
         max_sum = max(max_sum, r-min_sum)

      return max_sum

    -DISCARD THE SUM IF IT IS LESS THAN ZERO


13. Pascal's triangle
    - While updating the triangle on the same array,
      the trick is to update backwards

      since res[j] = res[j] + res[j-1]
      # res[j-1] will already be updated with the previous value 
      # if updated res  while moving forward

14. min-cost-climbing-stairs
    if you are starting a loop from index 2
    YOU NEED TO INITIALIZE VALUES AT index 0 AND index 1

    dp[0] = cost[0]
    dp[1] = cost[1]
   
    for i in range(2, n):
        dp[i] = cost[i] + min(dp[i-1] , dp[i-2])


- Potential bug in count_of_subset_sums(line 6)

15. Longest palindromic subsequence
    -We found a new way to traverse the 2d array
     diagonally, by keeping a constant gap between i and j in one pass
     and increasing the gap by one after each pass
     for k in range(1, len(s) + 1):
         for i in range(len(s) - k + 1):
            j = k + i - 1

    -Initialize gap from 1 to n
    -Initialize i from  0 to n-gap # reduce i's range at every iteration
    -add gap to i for j

    for gap in range(1, n):
      for i in range(n - gap):
         j = i+gap


16. Egg dropping problem
    -Our approach: binary search (log n) 

17. Rod cutting problem
    -For each row i and column j
     Cut a rod of length j using cuts from 0 to i

     rows - i - cuts_of_rod (0 to i)
     columns - j - piece_length - (o to len(rod))

     T[i-1][j] represents previous row same column

18. Compute binomial coefficient
    -min(i,k) since we do need (3,3) as intermediate value
     for computing (4,2)
    -C(n,0) = C(n,n) = 1
     C(n,k) = C(n-1, k-1) + C(n-1, k)



++++-palindromic partitioning
-egg dropping problem
-scrambled strings
-Minimum/maximum value of an expression

YELLOW QUESTIONS
18 July 2021
-Word break using memoization - https://logicmojo.com/sub_videos/38
-min cuts - partition palindrome -https://logicmojo.com/sub_videos/38
                                - https://leetcode.com/problems/palindrome-partitioning-ii/description/


21 July 2021
-Egg dropping problem
-Dry run THIS - https://leetcode.com/problems/super-egg-drop/discuss/158974/C%2B%2BJavaPython-2D-and-1D-DP-O(KlogN)

23 July 2021
-(done)Rod cutting problem - Logicmojo

28 July 2021
-Matrix chain multiplication - How tf is this happening?
   for i in range(1, n):
      m[i][i] = 0

   # L is chain length.
   for L in range(2, n):
      for i in range(1, n-L + 1):
         j = i + L-1