Key Learnings: NQueens
   - horizontally
     for z in range(col):
         print(m[fixed_row][z])
   
   - vertically
     for z in range(row):
         print(m[z][fixed_col])

   -THINK BEFORE YOU TYPE ANYTHING PLEASEEEE
    be it a loop, a condition, or a variable, or some assignment

   -Diagonal i == j 
   -Anti diagonal i + j == n-1

   -for r, c in zip(range(row, -1, -1), range(col, -1, -1)):
    If one of the range is exhausted the entire loop gets exhausted

   -NQUEENS is a hard problem
    break it into Subproblems

    -place a queen at a position and see if it is safe
     -check principal, secondary diagonal and the same ROW
    
    -if yes keep the postion and move to the next column
    -else backtrack to previous column

   -RENAME MATRIX as matrix
   -RENAME ARRAY as ar
   -AVOID NAMING DATA STRUCTURE WITH A SINGLE VARIABLE

Key Learnings: Generate combination of parantheses
    # first if condition
    if open_count > close_count:
        s[index] = "}"
        combination_parantheses(s, index+1, open_count, close_count+1)

    # second if condition 
    if open_count < N:
        s[index] = "{"
        combination_parantheses(s, index+1, open_count+1, close_count)

    -we did not add a return statement to the recursive call
     because otherwise WE WOULD NOT BE ABLE TO RUN THE SECOND IF CONDITION


Key Learnings: Combinational sum 
    -Whenever we append() we pop() within the same if condition
    -Whenever we swap, we swap it back again in the same if condition
    -Whenever we set, value as 1, we set it back again in the same if condition

Key Learnings: Rat in a maze
    -All backtracking problems are basically dfs

    #INCORRECT
    -if i+1 < N and j+1 < N and  maze[i+1][j] == 0: 
    -if i < N and j < N and  maze[i+1][j] == 0: 

    #CORRECT
    -if i+1 < N and j < N and  maze[i+1][j] == 0: 


Key Learnings: Knight Walk problem
    -For finding shortest distance in a graph we always use BFS
    -It is similar to - shortest path in unweighted graph
    -worst-case time complexity as O(N^2) 

    -Breadth first search - Extra memory, usually a queue, is needed to keep track of the 
    child nodes that were ENCOUNTERED but NOT YET EXPLORED.

    -CHECK FOR COMPLETION when you are about to POP THE NODE 
     not before you insert in the queue

Key Learnings: Sudoku solver - 1
    -Determining sectors
     row_val = row//3
     col_val = col//3
     sector = 3*row_val + col_val

    -Recursion must always be present inside a loop for backtracking

    -USE A STOPWATCH BEFORE STARTING ANYY PROBLEM 
    -IN A CONDITION OF BRAIN FREEZE
     1. CLEAR YOUR THOUGHTS
     2. FOCUS YOUR BRAIN TO SIT 
     3. BREAK THE SOLUTION DOWN
     4. MODULARIZE THE CODE
