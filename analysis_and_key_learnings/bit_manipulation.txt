Bit manipulation
1. used in data compression, error detection, encryption algo, low level device correction
2. AND, OR, XOR, NOT and bit shifts (a << b , a >> b)
3. many fold speed ups as bit manipulation are processed in parallel

4. python is an interpreted language not compiled
   python has an infinite length binary number representation
   so to avoid that we are mask the number with a 32 bit mask
   so that all operations occur in a 32 bit range

   mask = 0xFFFFFFFF

5. 2's complement has no concept on negative zero
   negative numbers are stored as 2's complement(we always store positive numbers)
   2's complement = 1's complement + 1

   12 = 1100
   ~12 = actual(we require) 0011
         stored as (-13) 1's complement of 13 + 1
         13                       = 1101
         1's complement of 13     = 0010
         +1                       = 0011

6. union = a|b (| is the pipe character)
   interconnection = a&b

   set bit at particular postion 
          c = 21 '0b10101'
          c = c | 1 << 3
          c = 29 '0b11101'
                    43210 - position

   clear bit at particular postion 
         c = 29 '0b11101'
         c = c & ~(1<<3)
         c = 21 '0b10101'

   check if bit at particular postion is set
         c & (1<<bit) != 0 #if this true bit is set at that postion
         c = 21 '0b10101'
         c & (1<<2) != 0 # will be true

   Remove last one bit
         a = 4 bin(100)
         a & (a-1) = 0

         c = 21 bin(10101)
         c & (c-1) = 20 bin(10100)

   Count Number of ones in binary number(Hamming weight)
         def count(n):
            count = 0
            while n:
               n = n & (n-1)
               count += 1

            return count


   set negation 3 will be represented as -4 in binary
                5 will be represented as -6

7. Find (left most 1)
   from math import log2
   bit_val = x & ~(x-1)
   least_significant_bit = int(math.log2(bit_val)) # ??? should it be least_significant_bit

   Also
   bitval = x & -x  

   since ~(x-1) == -x 
   Eg:  x      = 14
        -x     = 14
        ~(x-1) = 14


8. find most significant bit
   msb = int(math.log2(14))
   print(1 << msb) #or 2 ** msb
